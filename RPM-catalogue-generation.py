{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def add_Gabs_fit(color, Nbins_fit=128, path='./'):\n",
    "    \"\"\"\n",
    "    Gets the absolute G-magnitude form G - RP colours.\n",
    "    NOTE: uses an external file with mean MS locus and dispersion.\n",
    "    \"\"\"\n",
    "    g_rp = color\n",
    "    hist,edges = np.histogram(g_rp, bins=Nbins_fit, range=(0.35,1.1))\n",
    "    centres = (edges[1::]+edges[:-1])/2\n",
    "    g_rp_mode = centres[hist.argmax()]\n",
    "    g_rp[g_rp<0.35] = g_rp_mode\n",
    "    g_rp[g_rp>=1.1] = 1.099\n",
    "\n",
    "    ### NB: limits should be the same as used to obtain mean_GABS\n",
    "    spacing = edges[1]-edges[0]\n",
    "    g_rp_binned = ((g_rp-0.35)//spacing).astype(np.int)\n",
    "    g_rp_binned[g_rp_binned < 0] = 0\n",
    "\n",
    "    #file with Gabs and error for stars in each of the 128 bins\n",
    "    MSfit = np.load(f'{path}/MS-Gabs-mean-std.npy')\n",
    "    MSmean, MSstd = MSfit[[0,1]], MSfit[2]\n",
    "\n",
    "    # Returning the fitted Gabs, and with of the MS.\n",
    "    return np.array(MSmean[1])[g_rp_binned], np.array(MSstd)[g_rp_binned]\n",
    "\n",
    "def prop_Hg_uncertainty(**kw):\n",
    "    \"\"\"\n",
    "    Propagate uncertainties for Hg, ignores uncertainty in G-magnitude.\n",
    "    Procedurally generated, apologies for the long expression.\n",
    "    \"\"\"\n",
    "    from numpy import sqrt, log\n",
    "\n",
    "    pmra = kw['pmra']\n",
    "    pmdec = kw['pmdec']\n",
    "    pmra_error = kw['pmra_error']\n",
    "    pmdec_error = kw['pmdec_error']\n",
    "    pmra_pmdec_corr = kw['pmra_pmdec_corr']\n",
    "\n",
    "    return sqrt(((((((5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmdec)))) * (pmdec_error ** 2)) * (5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmdec))))) + (((((5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmdec)))) * pmra_pmdec_corr) * pmra_error) * pmdec_error) * (5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmra)))))) + (((((5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmra)))) * pmra_pmdec_corr) * pmra_error) * pmdec_error) * (5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmdec)))))) + (((5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmra)))) * (pmra_error ** 2)) * (5 * ((1 / (sqrt(((pmra ** 2) + (pmdec ** 2))) * log(10))) * ((0.5 * (((pmra ** 2) + (pmdec ** 2)) ** -0.5)) * (2 * pmra)))))))\n",
    "\n",
    "#to select rpm sample from gaia dr3\n",
    "def rpm_sel(**kw):\n",
    "    '''\n",
    "    Compute distance using RPM method see Viswanathan et al., 2023, MNRAS.\n",
    "    This code uses simple Schlegel 2D extinction and not the 3D integration used in the paper.\n",
    "    Because this is a halo catalogue, the results remain unchanged and saves some computer time.\n",
    "    '''\n",
    "\n",
    "    AG, ABP, ARP = gaia_extinction.get(kw['phot_g_mean_mag'],\n",
    "                                       kw['phot_bp_mean_mag'],\n",
    "                                       kw['phot_rp_mean_mag'],\n",
    "                                       kw['ebv'],\n",
    "                                       maxnit=1)\n",
    "\n",
    "\n",
    "    G_rp = (kw['phot_g_mean_mag'] - AG) - (kw['phot_rp_mean_mag'] - ARP)\n",
    "    G = kw['phot_g_mean_mag'] - AG\n",
    "    Gabs = G + 5*np.log10(kw['parallax']) - 10\n",
    "    PM = np.sqrt(kw['pmra']**2 + kw['pmdec']**2)\n",
    "    Hg = G + 5*np.log10(PM) - 10\n",
    "    Hg_uncertainty = prop_Hg_uncertainty(**kw)\n",
    "\n",
    "    # Some masks\n",
    "    POE5 = (kw['parallax']/kw['parallax_error'] > 5)\n",
    "    quality = (kw['ruwe'] < 1.4)&(AG < 2)&(np.log10(Hg/Hg_uncertainty) > 1.75)\n",
    "\n",
    "    #three linear fits to make cuts on the RPM diagram for the halo selection\n",
    "    p1=[11.61608077, -0.24101326]\n",
    "    p2=[8.13255287, 1.6000506 ]\n",
    "    p3=[11.49163297, -0.87464927]\n",
    "\n",
    "    #the lines\n",
    "    L1 = p1[1] + p1[0] * G_rp\n",
    "    L2 = p2[1] + p2[0] * G_rp\n",
    "    L3 = p3[1] + p3[0] * G_rp\n",
    "\n",
    "    #g_rp bounds\n",
    "    g_rp_left = 0.35\n",
    "    g_rp_right = 1.1\n",
    "    g_rp_split12=0.5285055589970487\n",
    "    g_rp_split23=0.7367195185319125\n",
    "\n",
    "    #tangential velocity bounds\n",
    "    VT_upper = 200\n",
    "    VT_lower = 800\n",
    "\n",
    "    #removing white dwarfs - see Viswanathan et al., 2023, MNRAS\n",
    "    WDS1 = (Gabs < L1 + 2)&(G_rp < g_rp_split12)\n",
    "    WDS2 = (Gabs < L2 + 2)&(G_rp > g_rp_split12)&(G_rp < g_rp_split23)\n",
    "    WDS3 = (Gabs < L3 + 2)&(G_rp > g_rp_split23)\n",
    "    WD = ((WDS1|WDS2|WDS3)*POE5)\n",
    "\n",
    "    #selection of halo stars in the RPM diagram\n",
    "    U1 = (Hg > L1 + 5*np.log10(VT_upper/4.74047))\n",
    "    L1 = (Hg < L1 + 5*np.log10(VT_lower/4.74047))\n",
    "    MSS1 = (G_rp > g_rp_left)&(G_rp < g_rp_split12)&(U1)&(L1)\n",
    "\n",
    "    U2 = (Hg > L2 + 5*np.log10(VT_upper/4.74047))\n",
    "    L2 = (Hg < L2 + 5*np.log10(VT_lower/4.74047))\n",
    "    MSS2 = (G_rp > g_rp_split12)&(G_rp < g_rp_split23)&(U2)&(L2)\n",
    "\n",
    "    U3 = (Hg > L3 + 5*np.log10(VT_upper/4.74047))\n",
    "    L3 = (Hg < L3 + 5*np.log10(VT_lower/4.74047))\n",
    "    MSS3 = (G_rp > g_rp_split23)&(G_rp < g_rp_right)&(U3)&(L3)\n",
    "\n",
    "    MS = ((MSS1|MSS2|MSS3)*(quality)*(~WD))\n",
    "\n",
    "    Grpm, Grpm_std = add_Gabs_fit(G_rp)\n",
    "\n",
    "    phot_dist = 10**((G - Grpm -10)/5)\n",
    "    phot_dist_uncertainty = phot_dist * np.log(10) * Grpm_std / 5\n",
    "\n",
    "    mask = MS  ## Return all main-sequence, good astrometry and not WD.\n",
    "    return(mask)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
